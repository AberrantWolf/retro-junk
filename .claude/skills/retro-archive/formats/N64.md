# Nintendo 64 ROM Format

## File Extensions
- `.z64` - Big-endian format (native, recommended for preservation)
- `.v64` - Byte-swapped format (16-bit word-swapped)
- `.n64` - Little-endian format (32-bit word-swapped)

## Byte Order Formats

N64 ROMs exist in three byte-order variants, identified by the first 4 bytes:

| Format | Magic Bytes | Description |
|--------|-------------|-------------|
| z64 | `80 37 12 40` | Big-endian (native N64 memory order) |
| v64 | `37 80 40 12` | 16-bit byte-swapped (every pair of adjacent bytes swapped) |
| n64 | `40 12 37 80` | 32-bit little-endian (every 4-byte group reversed) |

**Normalization to big-endian (z64):**
- v64 → z64: Swap every pair of adjacent bytes: `[B1,B0,B3,B2] → [B0,B1,B2,B3]`
- n64 → z64: Reverse every 4-byte group: `[B3,B2,B1,B0] → [B0,B1,B2,B3]`

All header field offsets and descriptions below assume big-endian (z64) byte order.

## Header Format (0x0000-0x003F)

The header is 64 bytes. The IPL3 boot code follows at 0x0040-0x0FFF.

| Offset | Size | Field |
|--------|------|-------|
| 0x0000 | 1 | Initial PI BSB DOM1 LAT REG (usually 0x80) |
| 0x0001 | 3 | PI BSD DOM1 Configuration Flags |
| 0x0004 | 4 | Clock Rate Override (0 = default) |
| 0x0008 | 4 | Boot Address (initial PC, commonly 0x80000400) |
| 0x000C | 4 | Libultra Version |
| 0x0010 | 4 | CRC1 (first 32 bits of check code) |
| 0x0014 | 4 | CRC2 (second 32 bits of check code) |
| 0x0018 | 8 | Reserved |
| 0x0020 | 20 | Game Title (ASCII, space-padded) |
| 0x0034 | 7 | Reserved |
| 0x003B | 1 | Category Code |
| 0x003C | 2 | Unique Game ID (2 ASCII characters) |
| 0x003E | 1 | Destination Code |
| 0x003F | 1 | ROM Version |

## Detection Method

1. Read first 4 bytes and match against one of the three magic values (`80 37 12 40`, `37 80 40 12`, or `40 12 37 80`)
2. This is sufficient for detection — the magic bytes are highly distinctive
3. Further validation (game code format, boot address, CRC) belongs in analysis, not detection

## Game Code Format (0x003B-0x003E)

The 4-byte game code encodes media type, game identity, and region:

| Offset | Field | Description |
|--------|-------|-------------|
| 0x3B | Category | Media type code |
| 0x3C-0x3D | Unique ID | Two-character game identifier |
| 0x3E | Destination | Region/country code |

### Category Codes (0x3B)

| Code | Description |
|------|-------------|
| N | Game Pak |
| D | 64DD Disk |
| C | Expandable Game Pak (64DD combo) |
| E | Expandable 64DD Disk |
| Z | Aleck64 Game Pak |

### Destination Codes (0x3E)

| Code | Region |
|------|--------|
| J | Japan |
| E | North America (USA) |
| N | Canada |
| P | Europe |
| D | Germany (→ Europe) |
| F | France (→ Europe) |
| S | Spain (→ Europe) |
| I | Italy (→ Europe) |
| H | Netherlands (→ Europe) |
| W | Scandinavia (→ Europe) |
| X | Europe (variant) |
| Y | Europe (variant) |
| L | Europe (Gateway 64 PAL) |
| U | Australia |
| B | Brazil |
| K | Korea |
| C | China |
| A | All regions / World |

### Serial Number Format

N64 cartridge serials follow the format `NUS-CCUU-RRR`:
- `NUS` = Nintendo Ultra Sixty-four (fixed prefix)
- `C` = Category code (0x3B)
- `UU` = Unique game ID (0x3C-0x3D)
- Last character of the game code portion = Destination (0x3E)
- `RRR` = Region suffix (USA, JPN, EUR, etc.)

Example: Super Mario 64 USA = `NUS-NSME-USA` (N=GamePak, SM=game, E=USA)

## CRC Checksum Algorithm

The N64 header contains two 32-bit CRC values (CRC1 at 0x10, CRC2 at 0x14) computed over 1 MB of ROM data starting at offset 0x1000. The algorithm is implemented by the IPL3 boot code and uses the CIC lockout chip's seed value.

### CIC Variant Detection

The CIC variant is identified by computing a CRC32-IEEE of the IPL3 boot code (bytes 0x40-0x1000, 4032 bytes) and matching against known values:

| CRC32 of boot code | CIC Variant |
|---------------------|-------------|
| `0x6170A4A1` | CIC-6101 |
| `0x90BB6CB5` | CIC-6102 |
| `0x0B050EE0` | CIC-6103 |
| `0x98BC2C86` | CIC-6105 |
| `0xACC8580A` | CIC-6106 |

Source: [rom64](https://github.com/mroach/rom64) by mroach.

### CIC Seed Values

Most commercial games use CIC-6102. Different CIC variants use different seeds:

| CIC Variant | Seed Byte | Init Value |
|-------------|-----------|------------|
| CIC-6101 / 6102 / 7101 | 0x3F | `0xF8CA4DDC` |
| CIC-6103 / 7103 | 0x78 | `0xA3886759` |
| CIC-6105 / 7105 | 0x91 | `0xDF26F436` |
| CIC-6106 / 7106 | 0x85 | `0x1FEA617A` |

The seed byte is transformed into the initial accumulator value: `init = seed * 0x5D588B65 + 1` (truncated to 32 bits).

### Algorithm

The algorithm uses six 32-bit accumulators (t1–t6), all initialized to the CIC seed's init value.

**Data range:** bytes `0x1000` to `0x101000` (1,048,576 bytes = 1 MB), processed as big-endian 32-bit words.

Based on the original chksum64 by Andreas Sterbenz, confirmed against [n64chain's checksum.c](https://github.com/tj90241/n64chain/blob/master/tools/checksum.c) and [rom64's crc.go](https://github.com/mroach/rom64):

```
seed = <CIC init value>
t1 = t2 = t3 = t4 = t5 = t6 = seed

for each 32-bit big-endian word d at byte offset i in rom[0x1000..0x101000]:
    // t6 accumulates sum; t4 counts overflows
    k1 = t6 + d                      (wrapping u32 add)
    if k1 < t6:                      (overflow detected)
        t4 = t4 + 1

    t6 = k1
    t3 = t3 XOR d                    (unconditional XOR)

    r = rotate_left(d, d & 0x1F)     (rotate by low 5 bits)
    t5 = t5 + r                      (wrapping u32 add)

    if d < t2:
        t2 = t2 XOR r
    else:
        t2 = t2 XOR (t6 XOR d)       (note: t6 already updated)

    // t1 update differs by CIC variant:
    if CIC-6105:
        b = rom_u32_at(0x0750 + (i & 0xFF))
        t1 = t1 + (b XOR d)
    else:
        t1 = t1 + (d XOR t5)
```

**Final combination also differs by CIC variant:**

| CIC Variant | CRC1 | CRC2 |
|-------------|------|------|
| 6101, 6102, 6105 (default) | `t6 XOR t4 XOR t3` | `t5 XOR t2 XOR t1` |
| 6103 | `(t6 XOR t4) + t3` | `(t5 XOR t2) + t1` |
| 6106 | `(t6 * t4) + t3` | `(t5 * t2) + t1` |

All arithmetic is wrapping u32.

### Minimum ROM Size for CRC

ROMs must be at least `0x101000` bytes (1,052,672 bytes) to compute the CRC. Smaller ROMs (e.g., homebrew) may not have valid CRC values.

## Homebrew ROM Header Extensions (0x0034-0x003F)

Some homebrew tools use the reserved header area differently. When the value at 0x3C-0x3D is `"ED"`, the homebrew header format applies:

| Offset | Size | Field |
|--------|------|-------|
| 0x0034 | 4 | Controller configuration (ports 1-4) |
| 0x0038 | 1 | Flags (metadata, etc.) |
| 0x0039 | 3 | Reserved |
| 0x003C | 2 | Game ID ("ED" for homebrew header) |
| 0x003E | 1 | Reserved |
| 0x003F | 1 | Savetype (bitfield: RTC, region-free, save type) |

## Sources

- [N64brew Wiki ROM Header](https://n64brew.dev/wiki/ROM_Header)
- [n64checksum — CRC research and implementation](https://github.com/Dragorn421/n64checksum)
- [ipl3checksum — Rust/Python CRC library](https://github.com/decompollaborate/ipl3checksum)
